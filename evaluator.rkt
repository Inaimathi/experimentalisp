#lang racket/base
(require racket/tcp)
(provide exp-eval exp-apply global-env
	 fexpr-expand)

(require "model.rkt")

(define (exp-eval exp env)
  (cond ((self-evaluating? exp)
	 exp)
	((symbol? exp)
	 (let ((res (lookup env exp)))
	   (if (null? res)
	       (error (format "LOOKUP: undefined value '~a'" exp))
	       (cdr res))))
	((eq? 'the-env (car exp))
	 env)
	((eq? 'list (car exp))
	 (eval-args (cdr exp) env))
	((eq? 'fn (car exp))
	 (procedure env (cadr exp) (cddr exp)))
	((eq? 'fexpr (car exp))
	 (fexpr env (cadr exp) (cddr exp)))
	((eq? 'do (car exp))	 
	 (eval-sequence (cdr exp) env))
	((eq? 'if (car exp))
	 (if (true? (exp-eval (cadr exp) env))
	     (exp-eval (caddr exp) env)
	     (exp-eval (cadddr exp) env)))
	((eq? 'def (car exp))
	 (eval-definition (cadr exp) (caddr exp) env))
	((eq? 'set! (car exp))
	 (eval-assignment (cadr exp) (caddr exp) env))
	((eq? 'quote (car exp))
	 (car (cdr exp)))
	((pair? exp)
	 (exp-apply (car exp) (cdr exp) env))
	(else
	 (error (format "EVAL: unknown form '~a'" exp)))))

(define (eval-sequence seq env)
  (cond ((null? seq) '())
	((null? (cdr seq))
	 (exp-eval (car seq) env))
	(else
	 (exp-eval (car seq) env)
	 (eval-sequence (cdr seq) env))))

(define (eval-args args env)
  (map (lambda (exp) (exp-eval exp env)) args))

(define (eval-definition name exp env)
  (if (symbol? name)
      (bind! env name (exp-eval exp env))
      (error (format "EVAL-DEFINIION: tried binding non-symbol '~a'" name)))
  '())

(define (eval-assignment name exp env)
  (if (symbol? name)
      (re-bind! env name (exp-eval exp env))
      (error (format "EVAL-ASSIGNMENT: tried assigning to non-symbol '~a'" name)))
  exp)

(define (fexpr-expand op args env)
  (let ((fn (exp-eval op env)))
    (if (fexpr? fn)
	(eval-sequence 
	 (body-of fn) 
	 (arglist-env! 
	  (extend-env (environment-of fn))
	  (arglist-of fn)
	  args))
	(cons op args))))

(define (exp-apply op args env)
  (let ((fn (exp-eval op env)))
    (if (fexpr? fn)
	(exp-eval (fexpr-expand op args env) env)
	(let ((new-env (arglist-env!
			(extend-env (environment-of fn))
			(arglist-of fn)
			(eval-args args env))))
	  (cond ((primitive? fn)
		 ((body-of fn) new-env))
		((procedure? fn)
		 (eval-sequence (body-of fn) new-env)))))))

(define global-env 
  (let ((env (list (make-hash))))
    (prim! env f-expand (form) (if (pair? form) (fexpr-expand (car form) (cdr form) env) form))
    (prim! env eval (form) (exp-eval form env))
    (prim! env apply (op args) (exp-apply op args env))
    
    (prim! env + (a b) (+ a b))
    (prim! env - (a b) (- a b))
    (prim! env / (a b) (/ a b))
    (prim! env * (a b) (* a b))
    (prim! env = (a b) (if (equal? a b) 'true 'false))

    (prim! env pair? (a) (if (pair? a) 'true 'false))
    (prim! env car (a) (car a))
    (prim! env cdr (a) (cdr a))
    (prim! env cons (a b) (cons a b))

    (prim! env print (thing) (begin (displayln thing) '()))

    (prim! env open-in-file! (fname) (in-port (open-input-file fname) (cons 'file fname)))
    (prim! env open-out-file! (fname) (out-port (open-output-file fname #:exists 'append) (cons 'file fname)))
    ;; (prim! env connect (hostname port) (tcp-connect hostname port))
    
    (prim! env listen! (port) (in-port (tcp-listen port) (cons 'tcp-server port)))
    (prim! env accept! (port) 
	   (let ((lbl (cons 'tcp-socket (in-port-label))))
	     (let-values (((in out) (tcp-accept (in-port-pt port))))
	       (cons (in-port in lbl) (out-port out lbl)))))

    (prim! env connect! (hostname port)
	   (let ((lbl (list 'tcp-socket hostname port)))
	     (let-values (((in out) (tcp-connect hostname port)))
	       (cons (in-port in lbl) (out-port out lbl)))))

    (prim! env get-char! (a-port) (read-char (in-port-pt a-port)))
    (prim! env put-char! (a-port c) (write-char c (out-port-pt a-port)))
    (prim! env flush! (a-port) (flush-output (out-port-pt a-port)))
    env))
